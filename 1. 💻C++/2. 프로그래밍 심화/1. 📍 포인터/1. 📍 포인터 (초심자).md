 # 📍 C++ 포인터(Pointer) 완전 정리 (초심자용)

## ✅ 포인터란?

**포인터(pointer)**는  
다른 변수의 **메모리 주소를 저장하는 변수**야.

> 쉽게 말하면:  
> **"값을 저장하는 게 아니라, 그 값이 어디에 있는지를 가리키는 변수"**

---

## ✅ 왜 포인터가 필요할까?

| 이유                              | 설명 |
|-----------------------------------|------|
| 변수의 메모리 주소를 다루기 위해 | 주소를 통해 값을 간접적으로 제어할 수 있음 |
| 함수에서 원본 값을 수정하기 위해 | 값이 아닌 주소를 넘겨주면 원본을 직접 수정 가능 |
| 동적 메모리 할당을 위해           | `new`, `delete`와 함께 사용됨 |
| 배열/문자열/구조체를 효율적으로 다루기 위해 | 메모리 효율과 빠른 접근 가능 |

---

## ✅ 포인터 선언

```cpp
int* p;
```

- `int* p;` → `int`형 데이터를 가리키는 포인터 변수 `p`를 선언한 것
- `*`는 **포인터 선언 또는 역참조에 사용됨**

---

## ✅ 주소연산자 `&` (주소 얻기)

```cpp
int a = 10;
int* p = &a;
```

- `&a`: 변수 `a`의 **메모리 주소**
- `p`: 변수 `a`의 주소를 담고 있는 포인터

---

## ✅ 역참조 연산자 `*` (주소가 가리키는 값 얻기)

```cpp
cout << *p << endl; // 출력: 10
```

- `*p`: 포인터 `p`가 가리키는 **실제 값**
- `*`는 "포인터가 가리키는 대상에 접근"할 때 사용됨

---

## ✅ 전체 예시

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 42;
    int* p = &a; // a의 주소를 p에 저장

    cout << "a의 값: " << a << endl;
    cout << "a의 주소: " << &a << endl;
    cout << "p의 값(주소): " << p << endl;
    cout << "p가 가리키는 값: " << *p << endl;

    *p = 100; // 포인터를 통해 a 값 변경
    cout << "변경된 a의 값: " << a << endl;

    return 0;
}
```

---

## ✅ 포인터 기본 도식

```
int a = 10;
int* p = &a;

[a] = 10       ← 변수
[p] = 주소 → a를 가리킴
[*p] = 10      ← a의 값
```

---

## ✅ 포인터의 흔한 활용

1. **함수에 주소 전달 (call by reference)**
2. **배열과 포인터 관계**
3. **동적 메모리 할당 (`new`, `delete`)**
4. **문자열 (`char*`)**
5. **구조체나 클래스 포인터 (`->`)**

---

## ✅ 주의할 점

- 포인터는 **초기화 없이 사용하면 위험** (쓰레기 주소 참조)
- 포인터는 잘못된 메모리를 건드리면 **Segmentation fault (세그폴트)** 발생 가능
- 항상 유효한 주소를 참조해야 함

---

## ✅ 요약 정리

| 항목          | 설명 |
|---------------|------|
| 포인터        | 변수의 주소를 저장하는 변수 |
| 선언          | `int* p;` → int형 포인터 |
| 주소 얻기     | `&a` → 변수 a의 주소 |
| 역참조        | `*p` → 주소가 가리키는 값 |
| 필요성        | 메모리 직접 제어, 원본 수정, 동적 할당 등 |
| 주의사항      | 초기화 필수, 잘못된 주소 접근 위험 |

---

**포인터는 C++에서 매우 중요한 개념이지만 처음에는 어렵게 느껴질 수 있어.**  
그림처럼 "주소를 가리키는 화살표 변수"로 생각하면 이해가 쉬워진다!
