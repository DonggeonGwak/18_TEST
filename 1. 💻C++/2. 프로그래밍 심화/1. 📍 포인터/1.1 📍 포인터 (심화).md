# 📍 C++ 포인터(Pointer) 심화 설명

## ✅ 포인터란?

**포인터(pointer)**는 **다른 변수의 메모리 주소를 저장하는 변수**다.  
포인터를 통해 우리는 직접 메모리에 접근하거나, 값을 수정하거나, 동적 메모리를 제어할 수 있다.

---

## ✅ 1. 기본 문법

```cpp
int a = 10;
int* p = &a;
```

| 요소 | 의미 |
|------|------|
| `int* p` | `int` 타입 데이터를 가리키는 포인터 선언 |
| `&a` | 변수 `a`의 메모리 주소 |
| `*p` | 포인터 `p`가 가리키는 위치에 있는 값 |

---

## ✅ 2. 메모리 구조 관점에서 보기

```cpp
int a = 10;
int* p = &a;
```

- `a`: 정수 값 `10`을 저장하는 변수
- `p`: `a`의 주소를 저장하고 있는 포인터

📌 메모리 도식:

```
[a 주소]   ──┐
            ↓
[int* p] = [a의 주소]
[*p]    =  a의 값 (10)
```

`*p`를 통해 `a`를 간접적으로 읽거나 수정할 수 있다.

---

## ✅ 3. 포인터 연산

```cpp
int arr[3] = {10, 20, 30};
int* p = arr;

cout << *p << endl;     // 10
cout << *(p + 1) << endl; // 20
```

- 배열은 사실상 첫 번째 요소의 주소 (`&arr[0]`)이므로,
  `p + 1`은 다음 요소의 주소를 의미함.
- 포인터 연산은 자료형 크기만큼 이동 (int: 4바이트면 +4)

---

## ✅ 4. 포인터와 배열

```cpp
int arr[5] = {1,2,3,4,5};
int* p = arr;

for (int i = 0; i < 5; i++) {
    cout << *(p + i) << " ";
}
```

- 배열 이름 자체가 포인터처럼 작동
- `arr[i]` == `*(arr + i)`

---

## ✅ 5. 함수에서 포인터 사용

### ❌ 값 복사 (Call by Value)

```cpp
void modify(int x) { x = 100; }
```

- 원본 변경 X

### ✅ 포인터 사용 (Call by Pointer)

```cpp
void modify(int* x) { *x = 100; }

int a = 5;
modify(&a);  // a == 100
```

---

## ✅ 6. 동적 메모리 할당

```cpp
int* p = new int;     // int 하나를 heap에 동적 생성
*p = 42;

delete p;             // 해제
```

배열의 경우:

```cpp
int* arr = new int[10];
// 사용
delete[] arr;
```

- `new`: heap 영역에 메모리 할당
- `delete`: 해제 (해제 안 하면 메모리 누수 발생)

---

## ✅ 7. 다중 포인터

```cpp
int a = 5;
int* p = &a;
int** pp = &p;

cout << **pp << endl; // 5
```

- `*pp`: p의 값 (즉, a의 주소)
- `**pp`: a의 값

---

## ✅ 8. const와 포인터

| 선언                    | 의미 |
|-------------------------|------|
| `const int* p`          | 가리키는 **값 변경 불가**, 포인터 이동 가능 |
| `int* const p`          | 포인터 **고정**, 값은 변경 가능 |
| `const int* const p`    | **값도 고정**, **포인터도 고정**

예시:

```cpp
const int* p = &a;     // *p는 못 바꿈, p는 다른 주소 가능
int* const p = &a;     // p는 못 바꿈, *p는 가능
```

---

## ✅ 9. nullptr

C++11부터 도입된 **null 포인터를 나타내는 타입 안전 키워드**

```cpp
int* p = nullptr;
```

- `NULL`보다 타입 안정성이 높음
- 함수 오버로딩에서 ambiguous 문제 방지

---

## ✅ 10. 포인터를 쓰는 주요 이유

| 목적 | 설명 |
|------|------|
| 메모리 직접 제어 | 효율적인 리소스 관리 가능 |
| 참조 함수 전달 | 복사 비용 없이 원본 제어 |
| 동적 메모리 할당 | 런타임에 메모리 조절 가능 |
| 다형성           | 상속된 클래스에서 기본 클래스 포인터 사용 |

---

## ✅ 정리 요약

| 요소              | 설명 |
|-------------------|------|
| `*`               | 선언: 포인터 / 사용: 역참조 |
| `&`               | 변수의 주소값 |
| 포인터 연산       | 메모리 이동 |
| 포인터 vs 배열     | 배열 이름은 포인터처럼 작동 |
| 다중 포인터       | 포인터를 가리키는 포인터 |
| 동적 할당         | `new`, `delete` |
| const 포인터       | 가리키는 값 or 주소 제한 |
| nullptr           | 안전한 null 표현 |

---

**포인터는 C++의 핵심이자 고급 기능을 위한 필수 요소야.**  
복잡할 수 있지만, 메모리의 본질과 구조를 이해하는 강력한 도구이기도 해.
```
